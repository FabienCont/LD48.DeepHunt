{"version":3,"sources":["webpack:///./sources/theatre/modules/collide.js","webpack:///./sources/game/scripts/systems/common/hitbox.js","webpack:///./sources/theatre/modules/shape.js"],"names":["caller","collidePointPoint","A","B","x","y","collidePointRectangle","BCDE","width","height","collideRectangleRectangle","ABCD","EFGH","hitbox","entities","Object","entries","forEach","nameA","entityA","collides","hitboxComponentA","get","positionComponentA","collideableA","collideable","collideableTypesA","keys","length","nameB","entityB","hitboxComponentB","positionComponentB","indexOf","type","Rectangle","parameters","name","Point","push","apply","collide","penetration","top","right","bottom","left","previousPositionComponentA","previous","previousPositionComponentB","previousHitboxComponentA","previousHitboxComponentB","previousA","previousB","previousOverlapX","toFixed","previousOverlapY","direction","minValue","Infinity","directionKey","collision","delta","from","key","scope","scripts","snippets","call","dodge","this"],"mappings":"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","file":"1360_bundle.js","sourcesContent":["import { Point, Rectangle } from './shape.js';\n\nfunction collide(A, B) {\n  const parameters = [];\n\n  let name = 'collide';\n\n  if (A instanceof Point === true) {\n    parameters.push(A);\n\n    name += 'Point';\n  }\n\n  if (B instanceof Point === true) {\n    parameters.push(B);\n\n    name += 'Point';\n  }\n\n  if (parameters.indexOf(A) === -1\n    && A instanceof Rectangle === true) {\n    parameters.push(A);\n\n    name += 'Rectangle';\n  }\n\n  if (parameters.indexOf(B) === -1\n    && B instanceof Rectangle === true) {\n    parameters.push(B);\n\n    name += 'Rectangle';\n  }\n\n  return caller[name].apply(null, parameters);\n}\n\nfunction collidePointPoint(A, B) {\n  if (A.x !== B.x\n    || A.y !== B.y) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction collidePointRectangle(A, BCDE) {\n  if (A.x < BCDE.x\n    || A.x > BCDE.x + BCDE.width\n    || A.y < BCDE.y\n    || A.y > BCDE.y + BCDE.height) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction collideRectangleRectangle(ABCD, EFGH) {\n  if (ABCD.x + ABCD.width <= EFGH.x\n    || ABCD.x >= EFGH.x + EFGH.width\n    || ABCD.y + ABCD.height <= EFGH.y\n    || ABCD.y >= EFGH.y + EFGH.height) {\n    return false;\n  }\n\n  return true;\n}\n\nconst caller = {\n\n  collidePointPoint,\n  collidePointRectangle,\n  collideRectangleRectangle,\n};\n\n// exports current module as a function\nexport { collide };\n","import { collide } from 'modules/collide.js';\nimport { Rectangle } from 'modules/shape.js';\n\nfunction hitbox(entities) {\n  Object.entries(entities).forEach(([nameA, entityA]) => {\n    const collides = {};\n\n    const hitboxComponentA = entityA.get('hitbox');\n    const positionComponentA = entityA.get('position');\n\n    const collideableA = hitboxComponentA.collideable;\n\n    const collideableTypesA = Object.keys(collideableA);\n    if (collideableTypesA.length > 0) {\n      Object.entries(entities).forEach(([nameB, entityB]) => {\n        if (nameA === nameB) {\n          return;\n        }\n\n        const hitboxComponentB = entityB.get('hitbox');\n        const positionComponentB = entityB.get('position');\n\n        if (collideableTypesA.indexOf(hitboxComponentB.type) !== -1) {\n          const A = new Rectangle(\n\n            positionComponentA.x + hitboxComponentA.x - hitboxComponentA.width / 2,\n            positionComponentA.y + hitboxComponentA.y - hitboxComponentA.height / 2,\n            hitboxComponentA.width,\n            hitboxComponentA.height,\n          );\n\n          const B = new Rectangle(\n\n            positionComponentB.x + hitboxComponentB.x - hitboxComponentB.width / 2,\n            positionComponentB.y + hitboxComponentB.y - hitboxComponentB.height / 2,\n            hitboxComponentB.width,\n            hitboxComponentB.height,\n          );\n\n          if (collide(A, B) === true) {\n            const penetration = {\n\n              top: (A.y > B.y && A.y < B.y + B.height) ? B.height - (A.y - B.y) : 0,\n              right: (A.x + A.width > B.x && A.x + A.width < B.x + B.width) ? A.x + A.width - B.x : 0,\n              bottom: (A.y + A.height > B.y && A.y + A.height < B.y + B.height) ? A.y + A.height - B.y : 0,\n              left: (A.x > B.x && A.x < B.x + B.width) ? B.width - (A.x - B.x) : 0,\n            };\n\n            const previousPositionComponentA = entityA.get('position').previous;\n            const previousPositionComponentB = entityB.get('position').previous;\n\n            const previousHitboxComponentA = entityA.get('hitbox').previous;\n            const previousHitboxComponentB = entityB.get('hitbox').previous;\n\n            const previousA = new Rectangle(\n\n              previousPositionComponentA.x + previousHitboxComponentA.x - (previousHitboxComponentA.width / 2),\n              previousPositionComponentA.y + previousHitboxComponentA.y - (previousHitboxComponentA.height / 2),\n              previousHitboxComponentA.width,\n              previousHitboxComponentA.height,\n            );\n\n            const previousB = new Rectangle(\n\n              previousPositionComponentB.x + previousHitboxComponentB.x - (previousHitboxComponentB.width / 2),\n              previousPositionComponentB.y + previousHitboxComponentB.y - (previousHitboxComponentB.height / 2),\n              previousHitboxComponentB.width,\n              previousHitboxComponentB.height,\n            );\n\n            const previousOverlapX = !((previousA.x + previousA.width - previousB.x).toFixed(3) <= 0 || (previousB.x + previousB.width - previousA.x).toFixed(3) <= 0);\n            const previousOverlapY = !((previousA.y + previousA.height - previousB.y).toFixed(3) <= 0 || (previousB.y + previousB.height - previousA.y).toFixed(3) <= 0);\n\n            const top = previousOverlapX === true && previousOverlapY === false && previousA.y > A.y;\n            const right = previousOverlapY === true && previousOverlapX === false && previousA.x < A.x;\n            const bottom = previousOverlapX === true && previousOverlapY === false && previousA.y < A.y;\n            const left = previousOverlapY === true && previousOverlapX === false && previousA.x > A.x;\n\n            const direction = {\n\n              top,\n              right,\n              bottom,\n              left,\n            };\n            if (previousOverlapX === false\n                    && previousOverlapY === false) {\n              let minValue = Infinity;\n              let directionKey = '';\n\n              if (penetration.top > 0) {\n                directionKey = 'top';\n                minValue = penetration.top;\n              }\n              if (penetration.right > 0 && penetration.right < minValue) {\n                directionKey = 'right';\n                minValue = penetration.right;\n              }\n              if (penetration.bottom > 0 && penetration.bottom < minValue) {\n                directionKey = 'bottom';\n                minValue = penetration.bottom;\n              }\n              if (penetration.left > 0 && penetration.left < minValue) {\n                directionKey = 'left';\n                minValue = penetration.left;\n              }\n              if (directionKey !== '') {\n                direction[directionKey] = true;\n              }\n            }\n\n            const collision = {\n\n              delta: penetration,\n              from: direction,\n            };\n\n            if (!collides[hitboxComponentB.type])collides[hitboxComponentB.type] = [];\n            collides[hitboxComponentB.type].push([collision, entityB]);\n          }\n        }\n      });\n      collideableTypesA.forEach((key) => {\n        if (collides[key] && collideableA[key].collide) {\n          const { scope, name } = collideableA[key].collide;\n          this.scripts.snippets[scope][name].call(this, entityA, collides[key]);\n        } else if (collideableA[key].dodge) {\n          const { scope, name } = collideableA[key].dodge;\n          this.scripts.snippets[scope][name].call(this, entityA);\n        }\n      });\n    }\n  });\n}\n\nexport { hitbox };\n","function Circle(x, y, radius) {\n\n    this.radius = radius;\n    this.x = x;\n    this.y = y;\n}\n\nfunction Point(x, y) {\n\n    this.x = x;\n    this.y = y;\n}\n\nfunction Rectangle(x, y, width, height) {\n\n    this.height = height;\n    this.width = width;\n    this.x = x;\n    this.y = y;\n}\n\nfunction Segment(xa, ya, xb, yb) {\n\n    this.xa = xa;\n    this.xb = xb;\n    this.ya = ya;\n    this.yb = yb;\n}\n\n// exports current module as objects\nexport {Circle, Point, Rectangle, Segment};\n"],"sourceRoot":""}