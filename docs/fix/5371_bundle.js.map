{"version":3,"sources":["webpack:///./sources/game/scripts/systems/canvas2d/renderText.js"],"names":["renderText","context","this","Object","values","$cameras","forEach","camera","texts","getDicoElement","sort","a","b","destination","z","screen","opacity","textObject","info","rotate","text","fontSize","color","fontFamily","fontWeight","lineWidth","letterSpacing","textBaseline","textAlign","drawType","screenCam","textFontSize","scale","font","fillStyle","canvas","style","textMeasure","measureText","textWidth","width","textHeight","actualBoundingBoxDescent","isVisible","visible","x","opacityGlobal","alpha","globalAlpha","canvasX","position","canvasY","y","height","canvasWidth","canvasHeight","save","translate","Math","PI","cos","fillText","strokeText","restore"],"mappings":"qHAAA,IAAMA,EAAa,WAAsB,WAEjCC,EAAUC,KAAKD,QACrBE,OAAOC,OAAOF,KAAKG,UAAUC,SAAQ,SAACC,GACpC,IAIMC,EAJgBD,EAAOE,eAAe,QAIhBC,MAFX,SAACC,EAAGC,GAAJ,OAAUD,EAAEE,YAAYC,EAAIF,EAAEC,YAAYC,KAI7B,IAA1BP,EAAOQ,OAAOC,SAIlBR,EAAMF,SAAQ,SAACW,GAAe,IAE1BJ,EACEI,EADFJ,YAAaK,EACXD,EADWC,KAAMC,EACjBF,EADiBE,OAInBC,EAWEF,EAXFE,KACAC,EAUEH,EAVFG,SACAC,EASEJ,EATFI,MACAC,EAQEL,EARFK,WACAC,EAOEN,EAPFM,WACAC,EAMEP,EANFO,UACAC,EAKER,EALFQ,cACAC,EAIET,EAJFS,aACAC,EAGEV,EAHFU,UACAC,EAEEX,EAFFW,SACAb,EACEE,EADFF,QAGIc,EAAYvB,EAAOQ,OACnBgB,EAAeV,EAAWS,EAAUE,QAE1C,EAAK/B,QAAQwB,UAAYA,EAAYK,EAAUE,QAC/C,EAAK/B,QAAQgC,KAAb,UAAuBT,EAAvB,YAAqCO,EAArC,cAAuDR,GACvD,EAAKtB,QAAQiC,UAAYZ,EACzB,EAAKrB,QAAQ0B,aAAeA,EAC5B,EAAK1B,QAAQ2B,UAAYA,EACzB,EAAK3B,QAAQkC,OAAOC,MAAMV,cAA1B,UAA6CA,EAA7C,MACA,IAAMW,EAAc,EAAKpC,QAAQqC,YAAYlB,GAEvCmB,EAAYF,EAAYG,MACxBC,GAAcJ,EAAYK,yBAE1BC,EAAYpC,EAAOqC,QAEvB/B,EAAYgC,EAAIf,EAAUE,QAC1BnB,EAAYgC,EAAIf,EAAUE,QAC1BO,EAAYT,EAAUE,QACtBS,EAAaX,EAAUE,SAGnBc,EAAgB9B,EAAUc,EAAUd,QAE1C,GAAI8B,EAAgB,IACG,IAAdH,EAAoB,CAC3B,IAAMI,EAAQ9C,EAAQ+C,YAEtB/C,EAAQ+C,YAAcF,EAEtB,IAAMG,EAAUnB,EAAUe,IAAMhC,EAAYgC,EAAIf,EAAUE,SACnDzB,EAAO2C,SAASL,IAAMf,EAAUE,QACjCF,EAAUU,QAAU,GACpBW,EAAUrB,EAAUsB,IAAMvC,EAAYuC,EAAItB,EAAUE,SACnDzB,EAAO2C,SAASE,IAAMtB,EAAUE,QACjCF,EAAUuB,SAAW,GACrBC,EAAcf,EACdgB,EAAed,EAErBxC,EAAQuD,OACRvD,EAAQwD,UAAUR,EAAWK,EAAc,EACzCH,EAAWI,EAAe,GAC5BtD,EAAQkB,OAAQA,EAAOL,EAAI4C,KAAKC,GAAM,KACtC1D,EAAQ+B,MAAM,EAAG0B,KAAKE,IAAKzC,EAAO0B,EAAIa,KAAKC,GAAM,MACjD1D,EAAQ+B,MAAM0B,KAAKE,IAAKzC,EAAOiC,EAAIM,KAAKC,GAAM,KAAM,GAEnC,SAAb9B,EACF,EAAK5B,QAAQ4D,SAASzC,EAAM,EAAG,GACT,WAAbS,GACT,EAAK5B,QAAQ6D,WAAW1C,EAAM,EAAG,GAGnCnB,EAAQ8D,UAER9D,EAAQ+C,YAAcD","file":"5371_bundle.js","sourcesContent":["const renderText = function renderText() {\n  /* eslint prefer-destructuring: [\"error\", {VariableDeclarator: {object: false}}] */\n  const context = this.context;\n  Object.values(this.$cameras).forEach((camera) => {\n    const unsortedTexts = camera.getDicoElement('text');\n\n    const sortText = (a, b) => a.destination.z - b.destination.z;\n\n    const texts = unsortedTexts.sort(sortText);\n\n    if (camera.screen.opacity === 0) {\n      return;\n    }\n\n    texts.forEach((textObject) => {\n      const {\n        destination, info, rotate,\n      } = textObject;\n\n      const {\n        text,\n        fontSize,\n        color,\n        fontFamily,\n        fontWeight,\n        lineWidth,\n        letterSpacing,\n        textBaseline,\n        textAlign,\n        drawType,\n        opacity,\n      } = info;\n\n      const screenCam = camera.screen;\n      const textFontSize = fontSize * screenCam.scale();\n\n      this.context.lineWidth = lineWidth * screenCam.scale();\n      this.context.font = `${fontWeight} ${textFontSize}px ${fontFamily}`;\n      this.context.fillStyle = color;\n      this.context.textBaseline = textBaseline;\n      this.context.textAlign = textAlign;\n      this.context.canvas.style.letterSpacing = `${letterSpacing}px`;\n      const textMeasure = this.context.measureText(text);\n\n      const textWidth = textMeasure.width;\n      const textHeight = -textMeasure.actualBoundingBoxDescent;\n\n      const isVisible = camera.visible(\n\n        destination.x * screenCam.scale(),\n        destination.x * screenCam.scale(),\n        textWidth * screenCam.scale(),\n        textHeight * screenCam.scale(),\n      );\n\n      const opacityGlobal = opacity * screenCam.opacity;\n\n      if (opacityGlobal > 0\n            && isVisible === true) {\n        const alpha = context.globalAlpha;\n\n        context.globalAlpha = opacityGlobal;\n\n        const canvasX = screenCam.x() + destination.x * screenCam.scale()\n            - (camera.position.x() * screenCam.scale()\n            - screenCam.width() / 2);\n        const canvasY = screenCam.y() + destination.y * screenCam.scale()\n            - (camera.position.y() * screenCam.scale()\n            - screenCam.height() / 2);\n        const canvasWidth = textWidth;\n        const canvasHeight = textHeight;\n\n        context.save();\n        context.translate(canvasX - (canvasWidth / 2),\n          canvasY + (canvasHeight / 2));\n        context.rotate((rotate.z * Math.PI) / 180);\n        context.scale(1, Math.cos((rotate.x * Math.PI) / 180));\n        context.scale(Math.cos((rotate.y * Math.PI) / 180), 1);\n\n        if (drawType === 'fill') {\n          this.context.fillText(text, 0, 0);\n        } else if (drawType === 'stroke') {\n          this.context.strokeText(text, 0, 0);\n        }\n\n        context.restore();\n\n        context.globalAlpha = alpha;\n      }\n    });\n  });\n};\nexport { renderText };\n"],"sourceRoot":""}