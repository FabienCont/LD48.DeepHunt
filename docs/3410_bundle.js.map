{"version":3,"sources":["webpack:///./sources/theatre/modules/webGL/shaderUtils.js","webpack:///./sources/theatre/core/mat4.js","webpack:///./sources/game/scripts/systems/webgl/renderImages.js","webpack:///./sources/theatre/modules/webGL/shader/drawImageShader.js"],"names":["loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","scale","m","sx","sy","sz","dst","Float32Array","renderImages","context","this","Object","values","$cameras","forEach","camera","images","getDicoElement","sort","a","b","destination","z","shaderProgram","vsSource","fsSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","initShaderProgram","viewport","canvas","width","height","enable","BLEND","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","texcoordBuffer","useProgram","image","frame","opacity","isVisible","visible","x","screen","y","alpha","globalAlpha","position","offset","top","Math","min","right","max","bottom","left","program","img","srcX","srcY","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","tex","cacheIndex","imageCache","indexOf","textureCache","createTexture","push","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","isPOT","LINEAR_MIPMAP_LINEAR","generateMipmap","positionLocation","getAttribLocation","texcoordLocation","matrixLocation","getUniformLocation","textureMatrixLocation","textureLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","matrix","tx","ty","tz","m00","m01","m02","m03","m10","m11","m12","m13","m20","m21","m22","m23","m30","m31","m32","m33","translate","uniformMatrix4fv","texMatrix","translation","uniform1i","activeTexture","TEXTURE0","drawArrays","TRIANGLES","drawImage","abs","value"],"mappings":"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","file":"3410_bundle.js","sourcesContent":["// creates a shader of the given type, uploads the source and\n// compiles it.\n//\nfunction loadShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  // Send the source to the shader object\n\n  gl.shaderSource(shader, source);\n\n  // Compile the shader program\n\n  gl.compileShader(shader);\n\n  // See if it compiled successfully\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction initShaderProgram(gl, vsSource, fsSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n\n  // Create the shader program\n\n  const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  // If creating the shader program failed, alert\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    alert(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);\n    return null;\n  }\n\n  return shaderProgram;\n}\n\nexport { loadShader, initShaderProgram };\n","function multiply(a, b, dst) {\n  dst = dst || new Float32Array(16);\n  const b00 = b[0 * 4 + 0];\n  const b01 = b[0 * 4 + 1];\n  const b02 = b[0 * 4 + 2];\n  const b03 = b[0 * 4 + 3];\n  const b10 = b[1 * 4 + 0];\n  const b11 = b[1 * 4 + 1];\n  const b12 = b[1 * 4 + 2];\n  const b13 = b[1 * 4 + 3];\n  const b20 = b[2 * 4 + 0];\n  const b21 = b[2 * 4 + 1];\n  const b22 = b[2 * 4 + 2];\n  const b23 = b[2 * 4 + 3];\n  const b30 = b[3 * 4 + 0];\n  const b31 = b[3 * 4 + 1];\n  const b32 = b[3 * 4 + 2];\n  const b33 = b[3 * 4 + 3];\n  const a00 = a[0 * 4 + 0];\n  const a01 = a[0 * 4 + 1];\n  const a02 = a[0 * 4 + 2];\n  const a03 = a[0 * 4 + 3];\n  const a10 = a[1 * 4 + 0];\n  const a11 = a[1 * 4 + 1];\n  const a12 = a[1 * 4 + 2];\n  const a13 = a[1 * 4 + 3];\n  const a20 = a[2 * 4 + 0];\n  const a21 = a[2 * 4 + 1];\n  const a22 = a[2 * 4 + 2];\n  const a23 = a[2 * 4 + 3];\n  const a30 = a[3 * 4 + 0];\n  const a31 = a[3 * 4 + 1];\n  const a32 = a[3 * 4 + 2];\n  const a33 = a[3 * 4 + 3];\n  dst[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n  dst[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n  dst[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n  dst[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n  dst[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n  dst[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n  dst[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n  dst[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n  dst[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n  dst[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n  dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n  dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n  dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n  dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n  dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n  dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n  return dst;\n}\n\nfunction translate(m, tx, ty, tz, dst) {\n  // This is the optimized version of\n  // return multiply(m, translation(tx, ty, tz), dst);\n  dst = dst || new Float32Array(16);\n\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m03 = m[3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const m30 = m[3 * 4 + 0];\n  const m31 = m[3 * 4 + 1];\n  const m32 = m[3 * 4 + 2];\n  const m33 = m[3 * 4 + 3];\n\n  if (m !== dst) {\n    dst[0] = m00;\n    dst[1] = m01;\n    dst[2] = m02;\n    dst[3] = m03;\n    dst[4] = m10;\n    dst[5] = m11;\n    dst[6] = m12;\n    dst[7] = m13;\n    dst[8] = m20;\n    dst[9] = m21;\n    dst[10] = m22;\n    dst[11] = m23;\n  }\n\n  dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;\n  dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;\n  dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;\n  dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;\n\n  return dst;\n}\n\nfunction scaling(sx, sy, sz, dst) {\n  dst = dst || new Float32Array(16);\n\n  dst[0] = sx;\n  dst[1] = 0;\n  dst[2] = 0;\n  dst[3] = 0;\n  dst[4] = 0;\n  dst[5] = sy;\n  dst[6] = 0;\n  dst[7] = 0;\n  dst[8] = 0;\n  dst[9] = 0;\n  dst[10] = sz;\n  dst[11] = 0;\n  dst[12] = 0;\n  dst[13] = 0;\n  dst[14] = 0;\n  dst[15] = 1;\n\n  return dst;\n}\n\nfunction perspective(out, fovy, aspect, near, far) {\n  const f = 1.0 / Math.tan(fovy / 2);\n  let nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n\nfunction scale(m, sx, sy, sz, dst) {\n  // This is the optimized version of\n  // return multiply(m, scaling(sx, sy, sz), dst);\n  dst = dst || new Float32Array(16);\n\n  dst[0] = sx * m[0 * 4 + 0];\n  dst[1] = sx * m[0 * 4 + 1];\n  dst[2] = sx * m[0 * 4 + 2];\n  dst[3] = sx * m[0 * 4 + 3];\n  dst[4] = sy * m[1 * 4 + 0];\n  dst[5] = sy * m[1 * 4 + 1];\n  dst[6] = sy * m[1 * 4 + 2];\n  dst[7] = sy * m[1 * 4 + 3];\n  dst[8] = sz * m[2 * 4 + 0];\n  dst[9] = sz * m[2 * 4 + 1];\n  dst[10] = sz * m[2 * 4 + 2];\n  dst[11] = sz * m[2 * 4 + 3];\n\n  if (m !== dst) {\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n  }\n\n  return dst;\n}\n\nfunction orthographic(left, right, bottom, top, near, far, dst) {\n  dst = dst || new Float32Array(16);\n\n  dst[0] = 2 / (right - left);\n  dst[1] = 0;\n  dst[2] = 0;\n  dst[3] = 0;\n  dst[4] = 0;\n  dst[5] = 2 / (top - bottom);\n  dst[6] = 0;\n  dst[7] = 0;\n  dst[8] = 0;\n  dst[9] = 0;\n  dst[10] = 2 / (near - far);\n  dst[11] = 0;\n  dst[12] = (left + right) / (left - right);\n  dst[13] = (bottom + top) / (bottom - top);\n  dst[14] = (near + far) / (near - far);\n  dst[15] = 1;\n\n  return dst;\n}\n\nfunction translation(tx, ty, tz, dst) {\n  dst = dst || new Float32Array(16);\n\n  dst[0] = 1;\n  dst[1] = 0;\n  dst[2] = 0;\n  dst[3] = 0;\n  dst[4] = 0;\n  dst[5] = 1;\n  dst[6] = 0;\n  dst[7] = 0;\n  dst[8] = 0;\n  dst[9] = 0;\n  dst[10] = 1;\n  dst[11] = 0;\n  dst[12] = tx;\n  dst[13] = ty;\n  dst[14] = tz;\n  dst[15] = 1;\n\n  return dst;\n}\n\nfunction createMatrice() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport {\n  translate, createMatrice, perspective, scale, multiply, orthographic, scaling, translation,\n};\n","import { drawImageFragmentShader, drawImageVertexShader } from 'modules/webGL/shader/drawImageShader';\nimport { initShaderProgram } from 'modules/webGL/shaderUtils';\nimport {\n  translate, scale, orthographic, translation,\n} from 'core/mat4';\n\nconst renderImages = function () {\n  /* eslint prefer-destructuring: [\"error\", {VariableDeclarator: {object: false}}] */\n  const context = this.context;\n  Object.values(this.$cameras).forEach((camera) => {\n    let images = camera.getDicoElement('images');\n\n    const sortImages = (a, b) => a.destination.z - b.destination.z;\n\n    images = images.sort(sortImages);\n\n    const shaderProgram = initShaderProgram(context, drawImageVertexShader, drawImageFragmentShader);\n\n    // Tell WebGL how to convert from clip space to pixels\n    context.viewport(0, 0, context.canvas.width, context.canvas.height);\n    context.enable(context.BLEND);\n    // context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);\n    // context.blendFunc(context.ONE, context.ONE_MINUS_SRC_ALPHA);\n    context.blendFuncSeparate(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA, context.ONE, context.ONE_MINUS_SRC_ALPHA);\n\n    // Create a buffer.\n    const positionBuffer = context.createBuffer();\n    context.bindBuffer(context.ARRAY_BUFFER, positionBuffer);\n\n    // Put a unit quad in the buffer\n    const positions = [\n      0, 0,\n      0, 1,\n      1, 0,\n      1, 0,\n      0, 1,\n      1, 1,\n    ];\n    context.bufferData(context.ARRAY_BUFFER, new Float32Array(positions), context.STATIC_DRAW);\n\n    // Create a buffer for texture coords\n    const texcoordBuffer = context.createBuffer();\n    context.bindBuffer(context.ARRAY_BUFFER, texcoordBuffer);\n\n    // Put texcoords in the buffer\n    const texcoords = [\n      0, 0,\n      0, 1,\n      1, 0,\n      1, 0,\n      0, 1,\n      1, 1,\n    ];\n    context.bufferData(context.ARRAY_BUFFER, new Float32Array(texcoords), context.STATIC_DRAW);\n\n    // Tell WebGL to use our shader program pair\n    context.useProgram(shaderProgram);\n\n    images.forEach((image) => {\n      const {\n        destination, frame, opacity, source,\n      } = image;\n\n      const isVisible = camera.visible(\n\n        destination.x * camera.screen.scale(),\n        destination.y * camera.screen.scale(),\n        destination.width * camera.screen.scale(),\n        destination.height * camera.screen.scale(),\n      );\n\n      if (opacity > 0\n            && isVisible === true) {\n        const alpha = context.globalAlpha;\n\n        context.globalAlpha = opacity;\n\n        const canvas = {\n          destination: {\n            x: camera.screen.x() + destination.x * camera.screen.scale()\n            - (camera.position.x() * camera.screen.scale()\n            - camera.screen.width() / 2),\n            y: camera.screen.y() + destination.y * camera.screen.scale()\n            - (camera.position.y() * camera.screen.scale()\n            - camera.screen.height() / 2),\n            width: destination.width * camera.screen.scale(),\n            height: destination.height * camera.screen.scale(),\n          },\n        };\n\n        const offset = {\n          top: Math.min(0, canvas.destination.y - camera.screen.y()),\n          right: Math.max(0, canvas.destination.x + canvas.destination.width\n            - (camera.screen.x() + camera.screen.width())),\n          bottom: Math.max(0, canvas.destination.y + canvas.destination.height\n            - (camera.screen.y() + camera.screen.height())),\n          left: Math.min(0, canvas.destination.x - camera.screen.x()),\n        };\n\n        context.globalAlpha = alpha;\n\n        drawImage(\n          context,\n          texcoordBuffer,\n          shaderProgram,\n          positionBuffer,\n          source,\n          frame.x - offset.left * (frame.width / canvas.destination.width),\n          frame.y - offset.top * (frame.height / canvas.destination.height),\n          frame.width - offset.right * (frame.width / canvas.destination.width)\n          - Math.abs(offset.left * (frame.width / canvas.destination.width)),\n          frame.height - offset.bottom * (frame.height / canvas.destination.height)\n          - Math.abs(offset.top * (frame.height / canvas.destination.height)),\n          canvas.destination.x - offset.left,\n          canvas.destination.y - offset.top,\n          canvas.destination.width - offset.right - Math.abs(offset.left),\n          canvas.destination.height - offset.bottom - Math.abs(offset.top),\n        );\n      }\n    });\n\n    images = [];\n  });\n};\n\nfunction isPOT(value) {\n  return value > 0 && ((value - 1) & value) === 0;\n}\n\nconst textureCache = [];\nconst imageCache = [];\n\nfunction createTexture(context, img) {\n  const tex = context.createTexture(img);\n\n  textureCache.push(tex);\n  imageCache.push(img);\n\n  context.bindTexture(context.TEXTURE_2D, tex);\n\n  context.texImage2D(context.TEXTURE_2D, 0, context.RGBA,\n    context.RGBA, context.UNSIGNED_BYTE, img);\n\n  // let's assume all images are not a power of 2\n  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\n  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\n  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\n  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\n\n  if (isPOT(img.width) && isPOT(img.height)) {\n    context.texParameteri(context.TEXTURE_2D,\n      context.TEXTURE_MIN_FILTER,\n      context.LINEAR_MIPMAP_LINEAR);\n    context.generateMipmap(context.TEXTURE_2D);\n  }\n\n  context.bindTexture(context.TEXTURE_2D, null);\n  return tex;\n}\n\nfunction drawImage(context, texcoordBuffer,\n  program,\n  positionBuffer,\n  img,\n  srcX, srcY, srcWidth, srcHeight,\n  dstX, dstY, dstWidth, dstHeight) {\n  let tex;\n  const cacheIndex = imageCache.indexOf(img);\n\n  if (cacheIndex !== -1) {\n    tex = textureCache[cacheIndex];\n  } else {\n    tex = createTexture(context, img);\n  }\n\n  // look up where the vertex data needs to go.\n  const positionLocation = context.getAttribLocation(program, 'a_position');\n  const texcoordLocation = context.getAttribLocation(program, 'a_texcoord');\n\n  // lookup uniforms\n  const matrixLocation = context.getUniformLocation(program, 'u_matrix');\n  const textureMatrixLocation = context.getUniformLocation(program, 'u_textureMatrix');\n  const textureLocation = context.getUniformLocation(program, 'u_texture');\n\n  // Setup the attributes to pull data from our buffers\n  context.bindBuffer(context.ARRAY_BUFFER, positionBuffer);\n  context.enableVertexAttribArray(positionLocation);\n  context.vertexAttribPointer(positionLocation, 2, context.FLOAT, false, 0, 0);\n  context.bindBuffer(context.ARRAY_BUFFER, texcoordBuffer);\n  context.enableVertexAttribArray(texcoordLocation);\n  context.vertexAttribPointer(texcoordLocation, 2, context.FLOAT, false, 0, 0);\n\n  // this matrix will convert from pixels to clip space\n  let matrix = orthographic(0, context.canvas.width, context.canvas.height, 0, -1, 1);\n\n  // this matrix will translate our quad to dstX, dstY\n  matrix = translate(matrix, dstX, dstY, 0);\n\n  // this matrix will scale our 1 unit quad\n  // from 1 unit to texWidth, texHeight units\n  matrix = scale(matrix, dstWidth, dstHeight, 2);\n\n  // Set the matrix.\n  context.uniformMatrix4fv(matrixLocation, false, matrix);\n\n  // Because texture coordinates go from 0 to 1\n  // and because our texture coordinates are already a unit quad\n  // we can select an area of the texture by scaling the unit quad\n  // down\n  let texMatrix = translation(srcX / img.width, srcY / img.height, 0);\n  texMatrix = scale(texMatrix, srcWidth / img.width, srcHeight / img.height, 1);\n\n  // Set the texture matrix.\n  context.uniformMatrix4fv(textureMatrixLocation, false, texMatrix);\n\n  // Tell the shader to get the texture from texture unit 0\n  context.uniform1i(textureLocation, 0);\n\n  context.bindTexture(context.TEXTURE_2D, tex);\n  context.activeTexture(context.TEXTURE0);\n\n  // draw the quad (2 triangles, 6 vertices)\n  context.drawArrays(context.TRIANGLES, 0, 6);\n}\n\nexport { renderImages };\n","const drawImageVertexShader = `attribute vec4 a_position;\nattribute vec2 a_texcoord;\n\nuniform mat4 u_matrix;\nuniform mat4 u_textureMatrix;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n   gl_Position = u_matrix * a_position;\n   v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0, 1)).xy;\n}`;\n\nconst drawImageFragmentShader = `precision mediump float;\n\nvarying vec2 v_texcoord;\n\nuniform sampler2D u_texture;\n\nvoid main() {\n   gl_FragColor = texture2D(u_texture, v_texcoord);\n}`;\n\nexport { drawImageFragmentShader, drawImageVertexShader };\n"],"sourceRoot":""}