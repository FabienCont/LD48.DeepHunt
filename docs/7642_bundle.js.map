{"version":3,"sources":["webpack:///./sources/game/scripts/systems/editor/renderGrid.js"],"names":["renderGrid","camera","this","$cameras","debug","screenCam","screen","ctx","context","step","$variables","$debug","stepGrid","scale","xPosScale","position","x","yPosScale","y","destination","width","height","Math","abs","beginPath","xPos","moveTo","lineTo","yPos","strokeStyle","alpha","globalAlpha","lineWidth","stroke"],"mappings":"oFAAA,SAASA,IACP,IAAMC,EAASC,KAAKC,SAASC,MACvBC,EAAYJ,EAAOK,OACnBC,EAAML,KAAKM,QAEXC,EAAOP,KAAKQ,WAAWC,OAAOC,SAAWP,EAAUQ,QAEnDC,EAAYb,EAAOc,SAASC,IAAMf,EAAOK,OAAOO,QAChDI,EAAYhB,EAAOc,SAASG,IAAMjB,EAAOK,OAAOO,QAChDM,EAAc,CAClBH,IAAKF,EAAYb,EAAOK,OAAOc,QAAU,GAAKX,EAC9CS,IAAKD,EAAYhB,EAAOK,OAAOe,SAAW,GAAKZ,EAC/CW,MAAOnB,EAAOK,OAAOc,QACrBC,OAAQpB,EAAOK,OAAOe,UAGxB,GAAKC,KAAKC,IAAIJ,EAAYE,OAASF,EAAYD,GAAKT,EAAQ,KAAQa,KAAKC,IAAIJ,EAAYC,MAAQD,EAAYH,GAAKP,EAAQ,IAAK,CAC7HF,EAAIiB,YACJ,IAAK,IAAIC,EAAON,EAAYH,EAAGS,GAAQN,EAAYC,MAAOK,GAAQhB,EAChEF,EAAImB,OAAOD,EAAM,GACjBlB,EAAIoB,OAAOF,EAAMN,EAAYE,QAI/B,IAAK,IAAIO,EAAOT,EAAYD,EAAGU,GAAQT,EAAYE,OAAQO,GAAQnB,EACjEF,EAAImB,OAAO,EAAGE,GACdrB,EAAIoB,OAAOR,EAAYC,MAAOQ,GAGhCrB,EAAIsB,YAAc,mBAElB,IAAMC,EAAQvB,EAAIwB,YAElBxB,EAAIwB,YAAc,GAElBxB,EAAIyB,UAAY,GAEhBzB,EAAI0B,SAEJ1B,EAAIwB,YAAcD,G","file":"7642_bundle.js","sourcesContent":["function renderGrid() {\n  const camera = this.$cameras.debug;\n  const screenCam = camera.screen;\n  const ctx = this.context;\n\n  const step = this.$variables.$debug.stepGrid * screenCam.scale();\n\n  const xPosScale = camera.position.x() * camera.screen.scale();\n  const yPosScale = camera.position.y() * camera.screen.scale();\n  const destination = {\n    x: (-xPosScale + camera.screen.width() / 2) % step,\n    y: (-yPosScale + camera.screen.height() / 2) % step,\n    width: camera.screen.width(),\n    height: camera.screen.height(),\n  };\n\n  if ((Math.abs(destination.height - destination.y) / step) < 100 || (Math.abs(destination.width - destination.x) / step) < 100) {\n    ctx.beginPath();\n    for (let xPos = destination.x; xPos <= destination.width; xPos += step) {\n      ctx.moveTo(xPos, 0);\n      ctx.lineTo(xPos, destination.height);\n    }\n\n    // the stroke will actually paint the current path\n    for (let yPos = destination.y; yPos <= destination.height; yPos += step) {\n      ctx.moveTo(0, yPos);\n      ctx.lineTo(destination.width, yPos);\n    }\n    // set the color of the line\n    ctx.strokeStyle = 'rgb(255,255,255)';\n\n    const alpha = ctx.globalAlpha;\n\n    ctx.globalAlpha = 0.3;\n    // just for fun\n    ctx.lineWidth = 0.5;\n    // for your original question - you need to stroke only once\n    ctx.stroke();\n\n    ctx.globalAlpha = alpha;\n  }\n}\n\nexport { renderGrid };\n"],"sourceRoot":""}